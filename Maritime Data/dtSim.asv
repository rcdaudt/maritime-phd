function [Y,X,tracks] = dtSim(pathName,cst,displ)
% Generate random state X and measurement Y for N time-steps
% X = [x dx/dt y dy/dt]
% Y = [x y]
% Rodrigo Daudt

% Assertions
N = cst.tmax;
assert(N == round(N))
assert(N > 3) % why not

% Parameters
dt = cst.T; % time-step
lambda = cst.nBirth; % poisson parameter for new objects
lambda_fa = cst.nFA; % poisson parameter for false alarms
P_survival = cst.pS; % probability of object survival
P_measure = cst.pD; % probability of measurement
% GET THIS FROM STRUCTURE
p_noise = 0.01; % position noise
assert(cst.sigmavel_x == cst.sigmavel_y)
v_noise = cst.sigmavel_x; % velocity noise
assert(cst.pixsize_x == cst.pixsize_y)
m_noise = cst.pixsize_x; % measurement noise

% Matrices
A = [1 dt 0 0;0 1 0 0;0 0 1 dt;0 0 0 1];
H = [1 0 0 0;0 0 1 0];

X = cell(N,1);
Y = cell(N,1);
tracks = cell(0,1);

n0 = round(4*rand()) + 2;

X{1} = [rand(1,n0);randn(1,n0);rand(1,n0);randn(1,n0)];
Y{1} = H*X{1};


for i = 2:N
    
    survival_var = rand(size(X{i-1},2),1);
    X_old = X{i-1};
    X_old_pruned = X_old(:,survival_var<P_survival);
    
    n = size(X_old_pruned,2);
    
    % Motion model
    X{i} = A*X_old_pruned + [p_noise*randn(1,n);v_noise*randn(1,n);p_noise*randn(1,n);v_noise*randn(1,n)];
    
    % New objects
    nn = poissrnd(lambda);
    if nn > 0
        new_objects = [rand(1,nn);randn(1,nn);rand(1,nn);randn(1,nn)];
        X{i} = [X{i} new_objects];
    end
    
    Y_full = H*X{i};
    measurement_var = rand(size(X{i},2),1);
    Y{i} = Y_full(:,measurement_var<P_measure);
    Y{i} = Y{i} + m_noise*randn(size(Y{i}));
    
    % False alarms
    n_fa = poissrnd(lambda_fa);
    if n_fa > 0
        Y{i} = [Y{i} rand(2,n_fa)];
    end
    
end

% Don't output GT velocity info
for j = 1:size(X)
    x = X{j};
    X{j} = x(
end


end